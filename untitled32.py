# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uqENd_xJ-1qKShTBGpdRSSE3-Pk6nQ0a
"""

import pandas as pd

df=pd.read_csv('/content/run_results.csv')
df.head()

df.info()

"""User-based"""

import pandas as pd
import numpy as np

class CoreRecommender:
    def __init__(self, ratings, n_neighbors=2):
        """
        User-based collaborative filtering recommender.

        Args:
            ratings (pd.DataFrame): Ratings matrix with users as columns and items as rows.
            n_neighbors (int): Number of similar users to consider for predictions.
        """
        self.ratings = ratings
        self.n_neighbors = n_neighbors

    def calculate_similarity(self, user1: str, user2: str) -> float:
        """
        Calculate similarity between two users using Pearson correlation.

        Args:
            user1: First user ID (column name in DataFrame)
            user2: Second user ID (column name in DataFrame)

        Returns:
            Similarity score between -1 and 1.
        """
        # Extract ratings for both users
        user1_ratings = self.ratings[user1]
        user2_ratings = self.ratings[user2]

        # Find common rated movies
        common_movies = user1_ratings.dropna().index.intersection(user2_ratings.dropna().index)

        if len(common_movies) < 2:
            return 0.0

        # Calculate means for common movies
        user1_mean = user1_ratings[common_movies].mean()
        user2_mean = user2_ratings[common_movies].mean()

        # Calculate the numerator and the denominators for Pearson correlation
        numerator = sum((user1_ratings[common_movies] - user1_mean) *
                        (user2_ratings[common_movies] - user2_mean))
        denominator = np.sqrt(sum((user1_ratings[common_movies] - user1_mean) ** 2)) * \
                      np.sqrt(sum((user2_ratings[common_movies] - user2_mean) ** 2))

        if denominator == 0:
            return 0.0

        return numerator / denominator

    def get_similar_users(self, target_user: str) -> dict:
        """
        Find similar users to a target user based on their ratings.

        Args:
            target_user: User ID to find similarities for (column name in DataFrame)

        Returns:
            Dictionary of {user: similarity_score} sorted by similarity.
        """
        similarities = {}

        for user in self.ratings.columns:
            if user != target_user:
                similarity = self.calculate_similarity(target_user, user)
                similarities[user] = round(similarity, 3)

        # Sort by similarity score, highest first
        return dict(sorted(similarities.items(), key=lambda x: x[1], reverse=True))

    def predict_rating(self, target_user: str, movie: str) -> float:
        """
        Predict rating for a movie using similar users.

        Args:
            target_user: User ID for prediction (column name in DataFrame)
            movie: Movie (row label in DataFrame)

        Returns:
            Predicted rating.
        """
        # Get similar users
        similarities = self.get_similar_users(target_user)

        # Select top N neighbors
        neighbors = dict(list(similarities.items())[:self.n_neighbors])

        weighted_sum = 0
        similarity_sum = 0

        # Calculate weighted average of ratings from similar users
        for user, similarity in neighbors.items():
            rating = self.ratings.loc[movie, user]

            if not pd.isna(rating):
                weighted_sum += rating * similarity
                similarity_sum += abs(similarity)

        if similarity_sum == 0:
            return None

        return round(weighted_sum / similarity_sum, 2)

# Example usage with the provided table
if __name__ == "__main__":
    # Initialize ratings DataFrame from the table
    ratings_data = {
        "User_1": [9.0, 8.7, 9.2, 8.9, np.nan],
        "User_2": [8.5, np.nan, 9.0, np.nan, 8.6],
        "User_3": [np.nan, 8.9, 9.1, 9.0, 8.8],
        "User_4": [9.2, 8.6, np.nan, 8.7, 8.5],
        "User_5": [8.8, 8.9, 9.3, np.nan, 8.7]
    }

    ratings_df = pd.DataFrame(ratings_data, index=[
        "The Shawshank Redemption", "Schindler's List", "The Godfather", "The Dark Knight", "Pulp Fiction"
    ])

    # Instantiate recommender
    recommender = CoreRecommender(ratings_df, n_neighbors=2)

    # Example: Get similar users to User_1
    print("User-based Similarities (User_1):")
    print(recommender.get_similar_users("User_1"))

    # Example: Predict rating for User_1 on "Pulp Fiction" using user-based CF
    print("\nPredicted Rating (User_1, 'Pulp Fiction'):")
    print(recommender.predict_rating("User_1", "Pulp Fiction"))

    # Example: Predict rating for User_2 on "The Dark Knight" using user-based CF
    print("\nPredicted Rating (User_2, 'The Dark Knight'):")
    print(recommender.predict_rating("User_2", "The Dark Knight"))

"""item-based"""

import pandas as pd
import numpy as np

class ItemBasedRecommender:
    def __init__(self, ratings, n_neighbors=2):
        """
        Item-based collaborative filtering recommender.

        Args:
            ratings (pd.DataFrame): Ratings matrix with items (movies) as rows and users as columns.
            n_neighbors (int): Number of similar items to consider for predictions.
        """
        self.ratings = ratings
        self.n_neighbors = n_neighbors

    def calculate_similarity(self, item1: str, item2: str) -> float:
        """
        Calculate similarity between two items using Pearson correlation.

        Args:
            item1: First item (row label in DataFrame)
            item2: Second item (row label in DataFrame)

        Returns:
            Similarity score between -1 and 1.
        """
        # Extract ratings for both items
        item1_ratings = self.ratings.loc[item1]
        item2_ratings = self.ratings.loc[item2]

        # Find common rated users
        common_users = item1_ratings.dropna().index.intersection(item2_ratings.dropna().index)

        if len(common_users) < 2:
            return 0.0

        # Calculate means for common users
        item1_mean = item1_ratings[common_users].mean()
        item2_mean = item2_ratings[common_users].mean()

        # Calculate the numerator and denominators for Pearson correlation
        numerator = sum((item1_ratings[common_users] - item1_mean) *
                        (item2_ratings[common_users] - item2_mean))
        denominator = np.sqrt(sum((item1_ratings[common_users] - item1_mean) ** 2)) * \
                      np.sqrt(sum((item2_ratings[common_users] - item2_mean) ** 2))

        if denominator == 0:
            return 0.0

        return numerator / denominator

    def get_similar_items(self, target_item: str) -> dict:
        """
        Find similar items to a target item based on their ratings.

        Args:
            target_item: Item to find similarities for (row label in DataFrame)

        Returns:
            Dictionary of {item: similarity_score} sorted by similarity.
        """
        similarities = {}

        for item in self.ratings.index:
            if item != target_item:
                similarity = self.calculate_similarity(target_item, item)
                similarities[item] = round(similarity, 3)

        # Sort by similarity score, highest first
        return dict(sorted(similarities.items(), key=lambda x: x[1], reverse=True))

    def predict_rating(self, target_user: str, item: str) -> float:
        """
        Predict rating for an item using similar items.

        Args:
            target_user: User ID for prediction (column name in DataFrame)
            item: Item (row label in DataFrame)

        Returns:
            Predicted rating.
        """
        # Get similar items
        similarities = self.get_similar_items(item)

        # Select top N neighbors
        neighbors = dict(list(similarities.items())[:self.n_neighbors])

        weighted_sum = 0
        similarity_sum = 0

        # Calculate weighted average of ratings from similar items
        for similar_item, similarity in neighbors.items():
            rating = self.ratings.loc[similar_item, target_user]

            if not pd.isna(rating):
                weighted_sum += rating * similarity
                similarity_sum += abs(similarity)

        if similarity_sum == 0:
            return None

        return round(weighted_sum / similarity_sum, 2)

# Example usage with the provided table
if __name__ == "__main__":
    # Initialize ratings DataFrame from the table
    ratings_data = {
        "User_1": [9.0, 8.7, 9.2, 8.9, np.nan],
        "User_2": [8.5, np.nan, 9.0, np.nan, 8.6],
        "User_3": [np.nan, 8.9, 9.1, 9.0, 8.8],
        "User_4": [9.2, 8.6, np.nan, 8.7, 8.5],
        "User_5": [8.8, 8.9, 9.3, np.nan, 8.7]
    }

    ratings_df = pd.DataFrame(ratings_data, index=[
        "The Shawshank Redemption", "Schindler's List", "The Godfather", "The Dark Knight", "Pulp Fiction"
    ])

    # Instantiate item-based recommender
    recommender = ItemBasedRecommender(ratings_df, n_neighbors=2)

    # Example: Get similar items to "Pulp Fiction"
    print("Item-based Similarities (Pulp Fiction):")
    print(recommender.get_similar_items("Pulp Fiction"))

    # Example: Predict rating for "User_1" on "Pulp Fiction" using item-based CF
    print("\nPredicted Rating (User_1, 'Pulp Fiction'):")
    print(recommender.predict_rating("User_1", "Pulp Fiction"))

    # Example: Predict rating for "User_2" on "The Dark Knight" using item-based CF
    print("\nPredicted Rating (User_2, 'The Dark Knight'):")
    print(recommender.predict_rating("User_2", "The Dark Knight"))